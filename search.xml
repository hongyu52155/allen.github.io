<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[me]]></title>
    <url>%2F2017%2F12%2F06%2Fme%2F</url>
    <content type="text"><![CDATA[一个吊儿郎当的小伙子。]]></content>
      <categories>
        <category>摄影</category>
      </categories>
      <tags>
        <tag>photo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[街拍闲逛]]></title>
    <url>%2F2017%2F12%2F06%2F%E9%97%B2%E9%80%9B%2F</url>
    <content type="text"><![CDATA[上海天山soho一角。 南京东路苹果直营店logo。 夜晚的灯光。]]></content>
      <categories>
        <category>摄影</category>
      </categories>
      <tags>
        <tag>photo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础架构 MVC & MVVM]]></title>
    <url>%2F2017%2F12%2F06%2FiOS%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[目录分级建议 Class层级下按TabBar模块进行分类(例如Base基类、工具类Tools、开源库等等) 每个TabBar模块下属子模块进行分类(例如HMModuleOne、HMModuleTwo等等)，子模块按照MVC，MVVM来做处理。 MVC Model 建议 命名xxxModel 例如(speed wallet) SWTextModel 可使用YYModel、或基类BaseModel做容错方法。字典数组之间转换 可在字段后增加注释12@property (copy, nonatomic) NSString *name; //姓名@property (copy, nonatomic) NSString *content; //内容 Controller 建议 UIView的创建和组织 网络请求&amp;数据处理 属性命名应见名之意、驼峰法命名 TableView&amp;Collection代理相关 数据配置cell&amp;view 行数过大可考虑拆分category 可在.h中增加方法名 12345#pragma mark- GET+ (void)getActionWithUrl:(NSString *)urlparams:(NSDictionary *)paramssuccess:(void(^)(id result))resultfiled:(void(^)(NSString *detail, NSError *error))errors; 可在.m中增加方法详细 1234567891011121314151617/**&lt;#Description#&gt;@param url &lt;#url description#&gt;@param size &lt;#size description#&gt;@param images &lt;#images description#&gt;@param result &lt;#result description#&gt;@param errors &lt;#errors description#&gt;*/快捷键 command + option + / 生成注释#pragma mark- GET+ (void)getActionWithUrl:(NSString *)urlparams:(NSDictionary *)paramssuccess:(void(^)(id result))resultfiled:(void(^)(NSString *detail, NSError *error))errors; View 建议 布局、事件绑定 使用model进行配置UI ViewModel 建议 VC业务逻辑拆分处理 数据请求 内存问题建议 block 循环引用问题 NSNotificationCenter &amp; RemoveObserver 匹配 Git相关使用建议 master 正式环境分支 dev 测试环境分支 dev-zhaoying 团队个人分支 dev-hongyu 团队个人分支 后续可建议，团队个人只可push个人分支，由团队负责人codeReView后进行合并等处理]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>oc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自动化神器 fastlane]]></title>
    <url>%2F2017%2F12%2F06%2F%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[Fastlane 是用Ruby语言编写的一套自动化工具集和框架，每一个工具实际都对应一个Ruby脚本，用来执行某一个特定的任务，而Fastlane核心框架则允许使用者通过类似配置文件的形式，将不同的工具有机而灵活的结合在一起，从而形成一个个完整的自动化流程。 先进行fastlane的安装1sudo gem install fastlane --verbose 确保Xcode安装了最新版本命令行工具1xcode-select --install 如果fastlane加载缓慢,请尝试运行1gem clean up 找到项根目目录1cd /Users/jsqb/Desktop/iOS 执行fastlane安装12执行 fastlane init配置开发者账户user，password，bundle identfier 会生成fastlane文件12Appfile - 包含你的app_id bundle id 如果上步init的时候你输入了正确的appId账号和密码会在这里生成正确的team_id信息Fastfile - 是最重要的一个文件，编写和定制我们打包脚本的一个文件 fastlane 工具 除fastlane命令,你还可以访问以下fastlane工具 deliver: 上传截图, 元数据, app应用程序到App Store supply: 上传Android app应用程序和元数据到Google Play snapshot: 自动捕获iOS app应用程序本地截图 screengrab: 自动捕获Android app应用程序本地截图 frameit: 快速截屏并将截屏放入设备中 pem: 自动生成和更新推送通知配置文件 sigh: 开发证书和描述文件下载 produce: 使用命令行在iTunes Connect上创建新的app和开发入口 cert: 自动创建和配置iOS代码签名证书 spaceship: Ruby 库访问 Apple开发者中心和 iTunes Connect pilot: 最好的方式管理你的TestFlight 测试人员和从终端构建 boarding: 最简单的方式邀请你的TestFlight beta测试人员 gym: iOS app打包签名自动化工具 match: 使用Git同步你的团队证书和配置文件 scan: 最简单方式测试你的 iOS 和 Mac apps 我们使用gym来做自动化打包1安装 sudo gem install gym 确保脚本文件在项目相同路径下12cd 到项目根目录 创建并编写脚本vim build_using_gym.sh vim编辑内容1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#!/bin/bash#计时SECONDS=0#脚本放置在与项目相同的路径下project_path=$(pwd)#取当前时间字符串添加到文件结尾now=$(date +&quot;%Y.%m.%d.%H.%M&quot;)pgy_user_key=&quot;b9df7d84c0ff1e447cca2be28154f467&quot;pgy_api_key=&quot;2ae59ed921d62503276eb16d85085031&quot;#指定项目的scheme名称scheme=&quot;PACK&quot;#指定要打包的配置 Debug Releaseconfiguration=&quot;Debug&quot;#指定打包所使用的输出方式，目前支持app-store(苹果商店), ad-hoc(蒲公英等发布平台), enterprise(￥299企业账户), development(￥99公司账户)export_method=&apos;development&apos;#指定项目地址workspace_path=&quot;$project_path/PACK.xcworkspace&quot;#指定输出路径output_path=&quot;project_path/ipa-speedWallet&quot;#指定输出归档文件地址archive_path=&quot;$output_path/PACK_$&#123;now&#125;.xcarchive&quot;#指定输出ipa地址ipa_path=&quot;$output_path/PACK_$&#123;now&#125;.ipa&quot;#ipa输出全地址ipa_newPath=&quot;$project_path/$output_path/极速钱包_$&#123;now&#125;.ipa&quot;#指定输出ipa名称ipa_name=&quot;极速钱包_$&#123;now&#125;.ipa&quot;#获取执行命令时的commit messagecommit_msg=&quot;$1&quot;#输出设定的变量值echo &quot;===workspace path: $&#123;workspace_path&#125;===&quot;echo &quot;===archive path: $&#123;archive_path&#125;===&quot;echo &quot;===ipa path: $&#123;ipa_newPath&#125;===&quot;echo &quot;===export method: $&#123;export_method&#125;===&quot;echo &quot;===commit msg: $1===&quot;#先清空前一次buildgym --workspace $&#123;workspace_path&#125; --scheme $&#123;scheme&#125; --clean --configuration $&#123;configuration&#125; --archive_path $&#123;archive_path&#125; --export_method $&#123;export_method&#125; --output_directory $&#123;output_path&#125; --output_name $&#123;ipa_name&#125;#上传到firfir publish $&#123;ipa_path&#125; -T fir_token -c &quot;$&#123;commit_msg&#125;&quot;echo &quot;ipa is Finished.Total time: $&#123;SECONDS&#125;s===，正上传蒲公英平台&quot;curl -F &quot;file=@$&#123;ipa_newPath&#125;&quot; -F &quot;uKey=$&#123;pgy_user_key&#125;&quot; -F &quot;_api_key=$&#123;pgy_api_key&#125;&quot; http://www.pgyer.com/apiv1/app/upload#输出总用时echo &quot;===打包+上传蒲同英成功. 总耗费时: $&#123;SECONDS&#125;s===&quot; 增加脚本执行权限1chmod +x build_using_gym.sh 运行脚本1./build_using_gym.sh 通过fastlane+蒲公英就可以来实现自动化打包发布功能]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>oc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS属性修饰关键字都有哪些?]]></title>
    <url>%2F2017%2F12%2F06%2FiOS%E5%B1%9E%E6%80%A7%E4%BF%AE%E9%A5%B0%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%2F</url>
    <content type="text"><![CDATA[atomic 原子性访问，对属性赋值的时候加锁 noatomic 非原子性访问，对属性赋值的时候不加锁，多线程并发访问会提高性能 strong OC对象-强引用，表示实例变量对传入的对象要有所有权关系 assige 非OC对象(number,bool)，简单赋值，引用计数不会增加 retain release旧对象，将旧对象的值赋予输入对象，属于浅拷贝-指针复制 copy setter方法进行copy操作,和retain处理流程一样，先旧值release，开辟内存copy对象，属于深拷贝-内容复制 weak 引用对象的引用计数不会增加，并在对象被释放的时候自动被设置为nil readwrite 可读可写，表示该属性同时拥有setter和getter readonly 只读属性，表示只有getter没有setter，不希望属性在类外部改变 nullable 声明的属性可以为空 nonnull 声明的属性不能为空 非集合类对象copy和mutableCopy12345[不可变对象 copy] //浅复制[不可变对象 mutableCopy] //深复制[可变对象 copy] //深复制[可变对象 mutableCopy] //深复制copy是不可以被修改的 mutableCopy是可以修改的 用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？ 因为父类指针可以指向子类对象,使用copy的目的是为了让本对象的属性不受外界影响,使用copy无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本 如果我们使用是strong,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性 代理为什么用weak修饰？ 确保代理执行后，在程序运行的时候不会造成循环引用,对象都会被顺利的销毁,所以会调用代理类的delloc方法 使用strong修饰，在程序运行的时候会造成循环引用，对象都不会的销毁，从而造成了内存泄露的问题 block为什么要用copy修饰？ block的内存地址开辟在栈区，栈区的特点就是创建的对象随时会被销毁掉，一但这个销毁了，再去调用这个对象，就会造成crash，用copy修饰后内存在堆区，不会函数调用完就结束，随对象销毁才销毁 assign与weak区别assign 适用于基本数据类型，weak 适用于 NSObject 对象 12345Q: assign 其实可以修饰对象，那为什么不用来修饰对象呢？被 assign 修饰的对象在释放后，指针的地址还是存在的，也就是说指针并没有被置为 nil，造成野指针。Q: 为什么可以用 assign 修饰基本数据类型？基本数据类型一般分配在栈上，栈中的内存是有系统自动管理的，不会造成野指针weak 修饰的对象在释放后，指针地址会被置为 nil。 weak实现原理？runtime 维护了一个weak表，本质是哈希表(hash)，key是所指对象的地址，value是weak指针的地址组成的数组 1.初始化创建时，runtime会调用objc_initWeak函数，创建一个new weak指针指向对象地址2.添加引用时，objc_initWeak会调用objc_storeWeak，更新指针指向，创建对应的weak弱引用表3.释放时，会调用clearDeallocating函数，通过对象地址也是key的值，找到对应的value数组，进行遍历，将其中的要处理的数据设为nil，把这个entry从weak表中删除，清理对象]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>oc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于AFN的网络库封装]]></title>
    <url>%2F2017%2F12%2F03%2F%E5%9F%BA%E4%BA%8EAFN%E7%BD%91%E7%BB%9C%E5%BA%93%2F</url>
    <content type="text"><![CDATA[第一层 HMRequest 功能 HTTP 常用请求方式 GET POST PUT PATCH DELETE POST 上传JSON数据 PHOTO 单张多张照片上传 HMRequest.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#import &lt;UIKit/UIKit.h&gt;#import &lt;Foundation/Foundation.h&gt;@interface HMRequestModel : HMBaseModel@property (nonatomic, strong) NSNumber *code;@property (nonatomic, copy) NSString *message;@endtypedef void(^HMRequestSuccessBlock)(id result, HMRequestModel *model);typedef void(^HMRequestFailureBlock)(NSString *msg);typedef NS_ENUM(NSInteger, HMRequestMethod) &#123;HTTP_REQUEST_TYPE_GET = 0,HTTP_REQUEST_TYPE_POST = 1,HTTP_REQUEST_TYPE_PUT = 2,HTTP_REQUEST_TYPE_PATCH = 3,HTTP_REQUEST_TYPE_DELETE = 4,&#125;;typedef NS_ENUM(NSInteger, HMRequestStatus) &#123;HTTP_REQUEST_STATUS_FAILURE = -1,HTTP_REQUEST_STATUS_SUCCESS = 0&#125;;@interface HMRequest : NSObject#pragma mark- http request+ (void)hm_requestActionWithUrl:(NSString *)urlparams:(NSDictionary *)paramsmethod:(HMRequestMethod)methodsuccess:(HMRequestSuccessBlock)successfailure:(HMRequestFailureBlock)failure;#pragma mark- json request+ (void)hm_postJsonDataWithUrl:(NSString *)urlparams:(NSDictionary *)paramssuccess:(HMRequestSuccessBlock)successfailure:(HMRequestFailureBlock)failure;#pragma mark- photo request+ (void)hm_upLoadPhotoWithUrl:(NSString *)urlparams:(NSDictionary *)paramsphotoSize:(CGSize)photoSizephotos:(NSArray *)photossuccess:(HMRequestSuccessBlock)successfailure:(HMRequestFailureBlock)failure;@end HMRequest.m123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166#import &quot;HMRequest.h&quot;@implementation HMRequestModel@end@implementation HMRequest+ (void)hm_requestActionWithUrl:(NSString *)urlparams:(NSDictionary *)paramsmethod:(HMRequestMethod)methodsuccess:(HMRequestSuccessBlock)successfailure:(HMRequestFailureBlock)failure&#123;// [HMServerConfig HMServerAddress] 为正式/测试环境前缀可自行处理NSString *requestUrl = HM_FORMAT_TWO(@&quot;%@%@&quot;, [HMServerConfig HMServerAddress], url);requestUrl = [requestUrl stringByAddingPercentEncodingWithAllowedCharacters:[NSCharacterSet URLQueryAllowedCharacterSet]];if (method == HTTP_REQUEST_TYPE_GET) &#123;[[HMRequest manager] GET:requestUrlparameters:paramsprogress:nilsuccess:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) &#123;HMRequestModel *model = [HMRequestModel yy_modelWithDictionary:responseObject];if ([model.code integerValue] == HTTP_REQUEST_STATUS_SUCCESS) success(responseObject, model);if ([model.code integerValue] == HTTP_REQUEST_STATUS_FAILURE) success(nil, model);&#125;failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;failure([HMRequest errorInfo:error]);&#125;];&#125;if (method == HTTP_REQUEST_TYPE_POST) &#123;[[HMRequest manager] POST:requestUrlparameters:params progress:nilsuccess:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) &#123;HMRequestModel *model = [HMRequestModel yy_modelWithDictionary:responseObject];if ([model.code integerValue] == HTTP_REQUEST_STATUS_SUCCESS) success(responseObject, model);if ([model.code integerValue] == HTTP_REQUEST_STATUS_FAILURE) success(nil, model);&#125;failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;failure([HMRequest errorInfo:error]);&#125;];&#125;if (method == HTTP_REQUEST_TYPE_PUT) &#123;[[HMRequest manager] PUT:requestUrlparameters:paramssuccess:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) &#123;HMRequestModel *model = [HMRequestModel yy_modelWithDictionary:responseObject];if ([model.code integerValue] == HTTP_REQUEST_STATUS_SUCCESS) success(responseObject, model);if ([model.code integerValue] == HTTP_REQUEST_STATUS_FAILURE) success(nil, model);&#125;failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;failure([HMRequest errorInfo:error]);&#125;];&#125;if (method == HTTP_REQUEST_TYPE_PATCH) &#123;[[HMRequest manager] PATCH:requestUrlparameters:paramssuccess:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) &#123;HMRequestModel *model = [HMRequestModel yy_modelWithDictionary:responseObject];if ([model.code integerValue] == HTTP_REQUEST_STATUS_SUCCESS) success(responseObject, model);if ([model.code integerValue] == HTTP_REQUEST_STATUS_FAILURE) success(nil, model);&#125;failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;failure([HMRequest errorInfo:error]);&#125;];&#125;if (method == HTTP_REQUEST_TYPE_DELETE) &#123;[[HMRequest manager] DELETE:requestUrlparameters:paramssuccess:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) &#123;HMRequestModel *model = [HMRequestModel yy_modelWithDictionary:responseObject];if ([model.code integerValue] == HTTP_REQUEST_STATUS_SUCCESS) success(responseObject, model);if ([model.code integerValue] == HTTP_REQUEST_STATUS_FAILURE) success(nil, model);&#125;failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;failure([HMRequest errorInfo:error]);&#125;];&#125;&#125;+ (void)hm_postJsonDataWithUrl:(NSString *)urlparams:(NSDictionary *)paramssuccess:(HMRequestSuccessBlock)successfailure:(HMRequestFailureBlock)failure&#123;NSString *requestUrl = HM_FORMAT_TWO(@&quot;%@%@&quot;, [HMServerConfig HMServerAddress], url);requestUrl = [requestUrl stringByAddingPercentEncodingWithAllowedCharacters:[NSCharacterSet URLQueryAllowedCharacterSet]];NSError *error;NSData *jsonData = [NSJSONSerialization dataWithJSONObject:params options:0 error:&amp;error];NSString *jsonString = [[NSString alloc] initWithData:jsonData encoding:NSUTF8StringEncoding];AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]];NSMutableURLRequest *request = [[AFJSONRequestSerializer serializer] requestWithMethod:@&quot;POST&quot; URLString:requestUrl parameters:nil error:nil];[request setValue:@&quot;application/json&quot; forHTTPHeaderField:@&quot;Content-Type&quot;];[request setValue:@&quot;application/json&quot; forHTTPHeaderField:@&quot;Accept&quot;];[request setHTTPBody:[jsonString dataUsingEncoding:NSUTF8StringEncoding]];[[manager dataTaskWithRequest:request completionHandler:^(NSURLResponse * _Nonnull response, id _Nullable responseObject, NSError * _Nullable error) &#123;if (responseObject) &#123;HMRequestModel *model = [HMRequestModel yy_modelWithDictionary:responseObject];if ([model.code integerValue] == HTTP_REQUEST_STATUS_SUCCESS) success(responseObject, model);if ([model.code integerValue] == HTTP_REQUEST_STATUS_FAILURE) success(nil, model);&#125; else &#123;failure([HMRequest errorInfo:error]);&#125;&#125;] resume];&#125;+ (void)hm_upLoadPhotoWithUrl:(NSString *)urlparams:(NSDictionary *)paramsphotoSize:(CGSize)photoSizephotos:(NSArray *)photossuccess:(HMRequestSuccessBlock)successfailure:(HMRequestFailureBlock)failure&#123;NSString *requestUrl = HM_FORMAT_TWO(@&quot;%@%@&quot;, [HMServerConfig HMServerAddress], url);requestUrl = [requestUrl stringByAddingPercentEncodingWithAllowedCharacters:[NSCharacterSet URLQueryAllowedCharacterSet]];NSLog(@&quot;url:%@\nparams:%@&quot;, requestUrl, params);AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];manager.requestSerializer = [AFHTTPRequestSerializer serializer];manager.responseSerializer = [AFJSONResponseSerializer serializer];[SVProgressHUD show];[manager POST:requestUrl parameters:params constructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt; _Nonnull formData) &#123;for (int i = 0; i &lt; photos.count; i++) &#123;NSData *imageData = UIImageJPEGRepresentation(photos[i], 0.6f);NSLog(@&quot;upload image size: %ld k&quot;, (long)(imageData.length / 1024));NSDateFormatter *formatter = [NSDateFormatter new];formatter.dateFormat = @&quot;yyyyMMddHHmmss&quot;;NSString *imageName = [formatter stringFromDate:[NSDate date]];NSString *fileName = [NSString stringWithFormat:@&quot;%@.jpg&quot;,imageName];[formData appendPartWithFileData:imageData name:@&quot;image&quot; fileName:fileName mimeType:@&quot;image/jpeg&quot;];&#125;&#125; progress:^(NSProgress * _Nonnull uploadProgress) &#123;&#125; success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) &#123;HMRequestModel *model = [HMRequestModel yy_modelWithDictionary:responseObject];if ([model.code integerValue] == HTTP_REQUEST_STATUS_SUCCESS) success(responseObject, model);if ([model.code integerValue] == HTTP_REQUEST_STATUS_FAILURE) success(nil, model);NSLog(@&quot;responseObject:%@&quot;, responseObject);[SVProgressHUD dismiss];&#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;failure([HMRequest errorInfo:error]);&#125;];&#125;+ (NSString *)errorInfo:(NSError *)error&#123;return error.userInfo[@&quot;message&quot;] ? error.userInfo[@&quot;message&quot;] : @&quot;网络断开连接，请稍后再试&quot;;&#125;+ (AFHTTPSessionManager *)manager&#123;AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];[manager.responseSerializer setAcceptableContentTypes:[NSSet setWithObjects:@&quot;text/html&quot;,@&quot;text/css&quot;,@&quot;text/json&quot;,@&quot;text/javascript&quot;,@&quot;text/plain&quot;,@&quot;application/json&quot;,@&quot;application/x-javascript&quot;,@&quot;application/javascript&quot;,@&quot;application/vnd.api+json&quot;, nil]];return manager;&#125;@end 第二层 HMService 功能- 按模块进行category类别划分（例如HMNetService、HMNetService+mine）HMService.h12345678910#import &quot;HMNetService.h&quot;@interface HMNetService (mine)// 个人信息 -&gt; 上传照片+ (void)upLoadWithPhotos:(NSArray *)photostype:(NSNumber *)typecomplete:(MultiActionBlock)complete;@end HMService.m12345678910111213141516171819202122#import &quot;HMNetService+mine.h&quot;static NSString * const upLoadImageUrl = @&quot;/upload/image&quot;;@implementation HMNetService (mine)+ (void)upLoadWithPhotos:(NSArray *)photostype:(NSNumber *)typecomplete:(MultiActionBlock)complete&#123;HMParams *params = [HMParams new];[params addParam:@&quot;type&quot; value:type];[HMRequest hm_upLoadPhotoWithUrl:upLoadImageUrlparams:params.paramsphotoSize:CGSizeMake(50, 50)photos:photossuccess:^(id result, HMRequestModel *model) &#123;complete(result, model, model.message);&#125; failure:^(NSString *msg) &#123;complete(nil, nil, msg);&#125;];&#125; 第三层 外部调用实现功能- block回调，非常简洁只关注最后结果做处理12345678910[HMNetService upLoadWithPhotos:@[photo]type:@(type)complete:^(NSDictionary *result, HMRequestModel *requestModel, NSString *message) &#123;if (result) &#123;// 成功处理&#125; else &#123;// 失败处理&#125;[[iToast makeText:message] show];&#125;];]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>oc</tag>
      </tags>
  </entry>
</search>
