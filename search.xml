<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[me]]></title>
    <url>%2F2017%2F12%2F06%2Fme%2F</url>
    <content type="text"><![CDATA[一个吊儿郎当的小伙子。]]></content>
      <categories>
        <category>摄影</category>
      </categories>
      <tags>
        <tag>photo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[街拍闲逛]]></title>
    <url>%2F2017%2F12%2F06%2F%E9%97%B2%E9%80%9B%2F</url>
    <content type="text"><![CDATA[上海天山soho一角。 南京东路苹果直营店logo。 夜晚的灯光。]]></content>
      <categories>
        <category>摄影</category>
      </categories>
      <tags>
        <tag>photo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础架构 MVC & MVVM]]></title>
    <url>%2F2017%2F12%2F06%2FiOS%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[目录分级建议 Class层级下按TabBar模块进行分类(例如Base基类、工具类Tools、开源库等等) 每个TabBar模块下属子模块进行分类(例如HMModuleOne、HMModuleTwo等等)，子模块按照MVC，MVVM来做处理。 MVC Model 建议 命名xxxModel 例如(speed wallet) SWTextModel 可使用YYModel、或基类BaseModel做容错方法。字典数组之间转换 可在字段后增加注释12@property (copy, nonatomic) NSString *name; //姓名@property (copy, nonatomic) NSString *content; //内容 Controller 建议 UIView的创建和组织 网络请求&amp;数据处理 属性命名应见名之意、驼峰法命名 TableView&amp;Collection代理相关 数据配置cell&amp;view 行数过大可考虑拆分category 可在.h中增加方法名 12345#pragma mark- GET+ (void)getActionWithUrl:(NSString *)urlparams:(NSDictionary *)paramssuccess:(void(^)(id result))resultfiled:(void(^)(NSString *detail, NSError *error))errors; 可在.m中增加方法详细 1234567891011121314151617/**&lt;#Description#&gt;@param url &lt;#url description#&gt;@param size &lt;#size description#&gt;@param images &lt;#images description#&gt;@param result &lt;#result description#&gt;@param errors &lt;#errors description#&gt;*/快捷键 command + option + / 生成注释#pragma mark- GET+ (void)getActionWithUrl:(NSString *)urlparams:(NSDictionary *)paramssuccess:(void(^)(id result))resultfiled:(void(^)(NSString *detail, NSError *error))errors; View 建议 布局、事件绑定 使用model进行配置UI ViewModel 建议 VC业务逻辑拆分处理 数据请求 内存问题建议 block 循环引用问题 NSNotificationCenter &amp; RemoveObserver 匹配 Git相关使用建议 master 正式环境分支 dev 测试环境分支 dev-zhaoying 团队个人分支 dev-hongyu 团队个人分支 后续可建议，团队个人只可push个人分支，由团队负责人codeReView后进行合并等处理]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>oc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自动化神器 fastlane]]></title>
    <url>%2F2017%2F12%2F06%2F%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[Fastlane 是用Ruby语言编写的一套自动化工具集和框架，每一个工具实际都对应一个Ruby脚本，用来执行某一个特定的任务，而Fastlane核心框架则允许使用者通过类似配置文件的形式，将不同的工具有机而灵活的结合在一起，从而形成一个个完整的自动化流程。 先进行fastlane的安装1sudo gem install fastlane --verbose 确保Xcode安装了最新版本命令行工具1xcode-select --install 如果fastlane加载缓慢,请尝试运行1gem clean up 找到项根目目录1cd /Users/jsqb/Desktop/iOS 执行fastlane安装12执行 fastlane init配置开发者账户user，password，bundle identfier 会生成fastlane文件12Appfile - 包含你的app_id bundle id 如果上步init的时候你输入了正确的appId账号和密码会在这里生成正确的team_id信息Fastfile - 是最重要的一个文件，编写和定制我们打包脚本的一个文件 fastlane 工具 除fastlane命令,你还可以访问以下fastlane工具 deliver: 上传截图, 元数据, app应用程序到App Store supply: 上传Android app应用程序和元数据到Google Play snapshot: 自动捕获iOS app应用程序本地截图 screengrab: 自动捕获Android app应用程序本地截图 frameit: 快速截屏并将截屏放入设备中 pem: 自动生成和更新推送通知配置文件 sigh: 开发证书和描述文件下载 produce: 使用命令行在iTunes Connect上创建新的app和开发入口 cert: 自动创建和配置iOS代码签名证书 spaceship: Ruby 库访问 Apple开发者中心和 iTunes Connect pilot: 最好的方式管理你的TestFlight 测试人员和从终端构建 boarding: 最简单的方式邀请你的TestFlight beta测试人员 gym: iOS app打包签名自动化工具 match: 使用Git同步你的团队证书和配置文件 scan: 最简单方式测试你的 iOS 和 Mac apps 我们使用gym来做自动化打包在生成的fastlane文件中新增 .env文件,配置文件内容如下可自行扩展 12345678910111213141516171819202122232425262728293031323334353637383940414243# .env全局配置文件# bundleIdAPP_IDENTIFIER = &quot;com.xqb.R&quot;# 蒲公英,更新描述PGY_UPDATE_DESCRIPTION = &quot;3.0.0测试包&quot;# 自动提交审核SUBMIT_FOR_REVIEW = false# 审核通过后立刻发布AUTOMATIC_RELEASE = false# 苹果开发者账号APPLE_ID = &quot;xxxxx@qq.com&quot;# 苹果开发者帐号密码FASTLANE_PASSWORD = &quot;xxxxx&quot;# 套装IDTEAM_ID = &quot;xxxx&quot;# APP元数据及截图存放路径METADATA_PATH = &quot;./metadata/TestGitProject&quot;SCREENSHOTS_PATH = &quot;./screenshots/TestGitProject&quot;# APP元数据及截图下载时，直接覆盖原有数据，不询问DELIVER_FORCE_OVERWRITE = true# 包名SCHEME = &quot;KDFDApp&quot;# 指定打包方式，Release 或者 DebugCONFIGURATION = &quot;Debug&quot;# 指定打包所使用的输出方式，目前支持app-store, package, ad-hoc, enterprise, developmentEXPORT_METHOD = &quot;enterprise&quot;# 蒲公英api key 蒲公英平台提供PGY_API_KEY = &quot;xxxx&quot;# 蒲公英api keyPGY_USER_KEY = &quot;xxxx&quot; Appfile 文件内容123app_identifier ENV[&apos;APP_IDENTIFIER&apos;]apple_id ENV[&apos;APPLE_ID&apos;]team_id ENV[&apos;TEAM_ID&apos;] Deliverfile 文件内容12app_identifier ENV[&apos;APP_IDENTIFIER&apos;]username ENV[&apos;APPLE_ID&apos;] 安装蒲公英的 Fastlane 插件1终端输入 astlane add_plugin pgyer 在生成的Gemfile文件中新增1gem &apos;cocoapods&apos; 最后我们编写fastlile文件来运行运行脚本1234567891011121314151617181920212223242526desc &quot;发布测试版本到蒲公英&quot;lane :qb_pgy dogym(scheme: ENV[&apos;SCHEME&apos;],silent: true, # 隐藏没有必要的信息include_symbols: true, # 是否生成符号表，默认trueinclude_bitcode: true, # 是否开启bitcode,默认trueclean:true, # 是否清空以前的编译信息 true：是configuration: ENV[&apos;CONFIGURATION&apos;],export_method: ENV[&apos;EXPORT_METHOD&apos;],output_name: &quot;极速钱包&quot;, # 输出文件名output_directory: &quot;./fastlane/bulid&quot;) # 指定输出文件夹pgyer(api_key: ENV[&apos;PGY_API_KEY&apos;],user_key: ENV[&apos;PGY_USER_KEY&apos;],update_description: ENV[&apos;PGY_UPDATE_DESCRIPTION&apos;])enddesc &quot;打包正式版本&quot;lane :qb_appStore dogym(scheme: ENV[&apos;SCHEME&apos;],output_name: &quot;极速钱包&quot;, # 输出的ipa名称silent: true, # 隐藏没有必要的信息clean: true, # 在构建前先cleanconfiguration: &quot;Release&quot;, # 配置为Release版本codesigning_identity: &quot;iPhone Distribution: Shanghai Peijun Information Technology Co., Ltd. (DFB9QG8MBN)&quot;, # 代码签名证书buildlog_path: &quot;./fastlane/onLine/fastlanelog&quot;, # fastlane构建ipa的日志输出目录output_directory: &quot;./fastlane/onLine&quot;)end 编写好后先把证书在工程中选择正确，我们就可以在终端中通过fastlane+蒲公英就可以来实现自动化打包发布功能1fastlane qb_pgy 最后上传成功用时 74s 这部分自动化文件没必要提交到远端服务器，我们在gitignore文件中新增忽略信息1*fastlane/ 通过fastfile 就可以定制各种自动化流程]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>oc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS属性修饰关键字都有哪些?]]></title>
    <url>%2F2017%2F12%2F06%2FiOS%E5%B1%9E%E6%80%A7%E4%BF%AE%E9%A5%B0%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%2F</url>
    <content type="text"><![CDATA[atomic 原子性访问，对属性赋值的时候加锁 noatomic 非原子性访问，对属性赋值的时候不加锁，多线程并发访问会提高性能 strong OC对象-强引用，表示实例变量对传入的对象要有所有权关系 assige 非OC对象(number,bool)，简单赋值，引用计数不会增加 retain release旧对象，将旧对象的值赋予输入对象，属于浅拷贝-指针复制 copy setter方法进行copy操作,和retain处理流程一样，先旧值release，开辟内存copy对象，属于深拷贝-内容复制 weak 引用对象的引用计数不会增加，并在对象被释放的时候自动被设置为nil readwrite 可读可写，表示该属性同时拥有setter和getter readonly 只读属性，表示只有getter没有setter，不希望属性在类外部改变 nullable 声明的属性可以为空 nonnull 声明的属性不能为空 非集合类对象copy和mutableCopy12345[不可变对象 copy] //浅复制[不可变对象 mutableCopy] //深复制[可变对象 copy] //深复制[可变对象 mutableCopy] //深复制copy是不可以被修改的 mutableCopy是可以修改的 用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？ 因为父类指针可以指向子类对象,使用copy的目的是为了让本对象的属性不受外界影响,使用copy无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本 如果我们使用是strong,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性 代理为什么用weak修饰？ 确保代理执行后，在程序运行的时候不会造成循环引用,对象都会被顺利的销毁,所以会调用代理类的delloc方法 使用strong修饰，在程序运行的时候会造成循环引用，对象都不会的销毁，从而造成了内存泄露的问题 block为什么要用copy修饰？ block的内存地址开辟在栈区，栈区的特点就是创建的对象随时会被销毁掉，一但这个销毁了，再去调用这个对象，就会造成crash，用copy修饰后内存在堆区，不会函数调用完就结束，随对象销毁才销毁 assign与weak区别assign 适用于基本数据类型，weak 适用于 NSObject 对象 12345Q: assign 其实可以修饰对象，那为什么不用来修饰对象呢？被 assign 修饰的对象在释放后，指针的地址还是存在的，也就是说指针并没有被置为 nil，造成野指针。Q: 为什么可以用 assign 修饰基本数据类型？基本数据类型一般分配在栈上，栈中的内存是有系统自动管理的，不会造成野指针weak 修饰的对象在释放后，指针地址会被置为 nil。 weak实现原理？runtime 维护了一个weak表，本质是哈希表(hash)，key是所指对象的地址，value是weak指针的地址组成的数组 1.初始化创建时，runtime会调用objc_initWeak函数，创建一个new weak指针指向对象地址2.添加引用时，objc_initWeak会调用objc_storeWeak，更新指针指向，创建对应的weak弱引用表3.释放时，会调用clearDeallocating函数，通过对象地址也是key的值，找到对应的value数组，进行遍历，将其中的要处理的数据设为nil，把这个entry从weak表中删除，清理对象]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>oc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于AFN的网络库封装]]></title>
    <url>%2F2017%2F12%2F03%2F%E5%9F%BA%E4%BA%8EAFN%E7%BD%91%E7%BB%9C%E5%BA%93%2F</url>
    <content type="text"><![CDATA[第一层 HMRequest 功能 HTTP 常用请求方式 GET POST PUT PATCH DELETE POST 上传JSON数据 PHOTO 单张多张照片上传 HMRequest.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#import &lt;UIKit/UIKit.h&gt;#import &lt;Foundation/Foundation.h&gt;@interface HMRequestModel : HMBaseModel@property (nonatomic, strong) NSNumber *code;@property (nonatomic, copy) NSString *message;@endtypedef void(^HMRequestSuccessBlock)(id result, HMRequestModel *model);typedef void(^HMRequestFailureBlock)(NSString *msg);typedef NS_ENUM(NSInteger, HMRequestMethod) &#123;HTTP_REQUEST_TYPE_GET = 0,HTTP_REQUEST_TYPE_POST = 1,HTTP_REQUEST_TYPE_PUT = 2,HTTP_REQUEST_TYPE_PATCH = 3,HTTP_REQUEST_TYPE_DELETE = 4,&#125;;typedef NS_ENUM(NSInteger, HMRequestStatus) &#123;HTTP_REQUEST_STATUS_FAILURE = -1,HTTP_REQUEST_STATUS_SUCCESS = 0&#125;;@interface HMRequest : NSObject#pragma mark- http request+ (void)hm_requestActionWithUrl:(NSString *)urlparams:(NSDictionary *)paramsmethod:(HMRequestMethod)methodsuccess:(HMRequestSuccessBlock)successfailure:(HMRequestFailureBlock)failure;#pragma mark- json request+ (void)hm_postJsonDataWithUrl:(NSString *)urlparams:(NSDictionary *)paramssuccess:(HMRequestSuccessBlock)successfailure:(HMRequestFailureBlock)failure;#pragma mark- photo request+ (void)hm_upLoadPhotoWithUrl:(NSString *)urlparams:(NSDictionary *)paramsphotoSize:(CGSize)photoSizephotos:(NSArray *)photossuccess:(HMRequestSuccessBlock)successfailure:(HMRequestFailureBlock)failure;@end HMRequest.m123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166#import &quot;HMRequest.h&quot;@implementation HMRequestModel@end@implementation HMRequest+ (void)hm_requestActionWithUrl:(NSString *)urlparams:(NSDictionary *)paramsmethod:(HMRequestMethod)methodsuccess:(HMRequestSuccessBlock)successfailure:(HMRequestFailureBlock)failure&#123;// [HMServerConfig HMServerAddress] 为正式/测试环境前缀可自行处理NSString *requestUrl = HM_FORMAT_TWO(@&quot;%@%@&quot;, [HMServerConfig HMServerAddress], url);requestUrl = [requestUrl stringByAddingPercentEncodingWithAllowedCharacters:[NSCharacterSet URLQueryAllowedCharacterSet]];if (method == HTTP_REQUEST_TYPE_GET) &#123;[[HMRequest manager] GET:requestUrlparameters:paramsprogress:nilsuccess:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) &#123;HMRequestModel *model = [HMRequestModel yy_modelWithDictionary:responseObject];if ([model.code integerValue] == HTTP_REQUEST_STATUS_SUCCESS) success(responseObject, model);if ([model.code integerValue] == HTTP_REQUEST_STATUS_FAILURE) success(nil, model);&#125;failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;failure([HMRequest errorInfo:error]);&#125;];&#125;if (method == HTTP_REQUEST_TYPE_POST) &#123;[[HMRequest manager] POST:requestUrlparameters:params progress:nilsuccess:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) &#123;HMRequestModel *model = [HMRequestModel yy_modelWithDictionary:responseObject];if ([model.code integerValue] == HTTP_REQUEST_STATUS_SUCCESS) success(responseObject, model);if ([model.code integerValue] == HTTP_REQUEST_STATUS_FAILURE) success(nil, model);&#125;failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;failure([HMRequest errorInfo:error]);&#125;];&#125;if (method == HTTP_REQUEST_TYPE_PUT) &#123;[[HMRequest manager] PUT:requestUrlparameters:paramssuccess:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) &#123;HMRequestModel *model = [HMRequestModel yy_modelWithDictionary:responseObject];if ([model.code integerValue] == HTTP_REQUEST_STATUS_SUCCESS) success(responseObject, model);if ([model.code integerValue] == HTTP_REQUEST_STATUS_FAILURE) success(nil, model);&#125;failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;failure([HMRequest errorInfo:error]);&#125;];&#125;if (method == HTTP_REQUEST_TYPE_PATCH) &#123;[[HMRequest manager] PATCH:requestUrlparameters:paramssuccess:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) &#123;HMRequestModel *model = [HMRequestModel yy_modelWithDictionary:responseObject];if ([model.code integerValue] == HTTP_REQUEST_STATUS_SUCCESS) success(responseObject, model);if ([model.code integerValue] == HTTP_REQUEST_STATUS_FAILURE) success(nil, model);&#125;failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;failure([HMRequest errorInfo:error]);&#125;];&#125;if (method == HTTP_REQUEST_TYPE_DELETE) &#123;[[HMRequest manager] DELETE:requestUrlparameters:paramssuccess:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) &#123;HMRequestModel *model = [HMRequestModel yy_modelWithDictionary:responseObject];if ([model.code integerValue] == HTTP_REQUEST_STATUS_SUCCESS) success(responseObject, model);if ([model.code integerValue] == HTTP_REQUEST_STATUS_FAILURE) success(nil, model);&#125;failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;failure([HMRequest errorInfo:error]);&#125;];&#125;&#125;+ (void)hm_postJsonDataWithUrl:(NSString *)urlparams:(NSDictionary *)paramssuccess:(HMRequestSuccessBlock)successfailure:(HMRequestFailureBlock)failure&#123;NSString *requestUrl = HM_FORMAT_TWO(@&quot;%@%@&quot;, [HMServerConfig HMServerAddress], url);requestUrl = [requestUrl stringByAddingPercentEncodingWithAllowedCharacters:[NSCharacterSet URLQueryAllowedCharacterSet]];NSError *error;NSData *jsonData = [NSJSONSerialization dataWithJSONObject:params options:0 error:&amp;error];NSString *jsonString = [[NSString alloc] initWithData:jsonData encoding:NSUTF8StringEncoding];AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]];NSMutableURLRequest *request = [[AFJSONRequestSerializer serializer] requestWithMethod:@&quot;POST&quot; URLString:requestUrl parameters:nil error:nil];[request setValue:@&quot;application/json&quot; forHTTPHeaderField:@&quot;Content-Type&quot;];[request setValue:@&quot;application/json&quot; forHTTPHeaderField:@&quot;Accept&quot;];[request setHTTPBody:[jsonString dataUsingEncoding:NSUTF8StringEncoding]];[[manager dataTaskWithRequest:request completionHandler:^(NSURLResponse * _Nonnull response, id _Nullable responseObject, NSError * _Nullable error) &#123;if (responseObject) &#123;HMRequestModel *model = [HMRequestModel yy_modelWithDictionary:responseObject];if ([model.code integerValue] == HTTP_REQUEST_STATUS_SUCCESS) success(responseObject, model);if ([model.code integerValue] == HTTP_REQUEST_STATUS_FAILURE) success(nil, model);&#125; else &#123;failure([HMRequest errorInfo:error]);&#125;&#125;] resume];&#125;+ (void)hm_upLoadPhotoWithUrl:(NSString *)urlparams:(NSDictionary *)paramsphotoSize:(CGSize)photoSizephotos:(NSArray *)photossuccess:(HMRequestSuccessBlock)successfailure:(HMRequestFailureBlock)failure&#123;NSString *requestUrl = HM_FORMAT_TWO(@&quot;%@%@&quot;, [HMServerConfig HMServerAddress], url);requestUrl = [requestUrl stringByAddingPercentEncodingWithAllowedCharacters:[NSCharacterSet URLQueryAllowedCharacterSet]];NSLog(@&quot;url:%@\nparams:%@&quot;, requestUrl, params);AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];manager.requestSerializer = [AFHTTPRequestSerializer serializer];manager.responseSerializer = [AFJSONResponseSerializer serializer];[SVProgressHUD show];[manager POST:requestUrl parameters:params constructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt; _Nonnull formData) &#123;for (int i = 0; i &lt; photos.count; i++) &#123;NSData *imageData = UIImageJPEGRepresentation(photos[i], 0.6f);NSLog(@&quot;upload image size: %ld k&quot;, (long)(imageData.length / 1024));NSDateFormatter *formatter = [NSDateFormatter new];formatter.dateFormat = @&quot;yyyyMMddHHmmss&quot;;NSString *imageName = [formatter stringFromDate:[NSDate date]];NSString *fileName = [NSString stringWithFormat:@&quot;%@.jpg&quot;,imageName];[formData appendPartWithFileData:imageData name:@&quot;image&quot; fileName:fileName mimeType:@&quot;image/jpeg&quot;];&#125;&#125; progress:^(NSProgress * _Nonnull uploadProgress) &#123;&#125; success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) &#123;HMRequestModel *model = [HMRequestModel yy_modelWithDictionary:responseObject];if ([model.code integerValue] == HTTP_REQUEST_STATUS_SUCCESS) success(responseObject, model);if ([model.code integerValue] == HTTP_REQUEST_STATUS_FAILURE) success(nil, model);NSLog(@&quot;responseObject:%@&quot;, responseObject);[SVProgressHUD dismiss];&#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;failure([HMRequest errorInfo:error]);&#125;];&#125;+ (NSString *)errorInfo:(NSError *)error&#123;return error.userInfo[@&quot;message&quot;] ? error.userInfo[@&quot;message&quot;] : @&quot;网络断开连接，请稍后再试&quot;;&#125;+ (AFHTTPSessionManager *)manager&#123;AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];[manager.responseSerializer setAcceptableContentTypes:[NSSet setWithObjects:@&quot;text/html&quot;,@&quot;text/css&quot;,@&quot;text/json&quot;,@&quot;text/javascript&quot;,@&quot;text/plain&quot;,@&quot;application/json&quot;,@&quot;application/x-javascript&quot;,@&quot;application/javascript&quot;,@&quot;application/vnd.api+json&quot;, nil]];return manager;&#125;@end 第二层 HMService 功能- 按模块进行category类别划分（例如HMNetService、HMNetService+mine）HMService.h12345678910#import &quot;HMNetService.h&quot;@interface HMNetService (mine)// 个人信息 -&gt; 上传照片+ (void)upLoadWithPhotos:(NSArray *)photostype:(NSNumber *)typecomplete:(MultiActionBlock)complete;@end HMService.m12345678910111213141516171819202122#import &quot;HMNetService+mine.h&quot;static NSString * const upLoadImageUrl = @&quot;/upload/image&quot;;@implementation HMNetService (mine)+ (void)upLoadWithPhotos:(NSArray *)photostype:(NSNumber *)typecomplete:(MultiActionBlock)complete&#123;HMParams *params = [HMParams new];[params addParam:@&quot;type&quot; value:type];[HMRequest hm_upLoadPhotoWithUrl:upLoadImageUrlparams:params.paramsphotoSize:CGSizeMake(50, 50)photos:photossuccess:^(id result, HMRequestModel *model) &#123;complete(result, model, model.message);&#125; failure:^(NSString *msg) &#123;complete(nil, nil, msg);&#125;];&#125; 第三层 外部调用实现功能- block回调，非常简洁只关注最后结果做处理12345678910[HMNetService upLoadWithPhotos:@[photo]type:@(type)complete:^(NSDictionary *result, HMRequestModel *requestModel, NSString *message) &#123;if (result) &#123;// 成功处理&#125; else &#123;// 失败处理&#125;[[iToast makeText:message] show];&#125;];]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>oc</tag>
      </tags>
  </entry>
</search>
