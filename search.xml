<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[iOS代码混淆]]></title>
    <url>%2F2018%2F09%2F22%2FiOS%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86%2F</url>
    <content type="text"><![CDATA[iOS 审核4.3金融类APP马甲包问题 利用shell脚本更改.h中暴露的接口 用宏定义随机字母代替混淆代码 1.在项目跟目录下创建 confuse.sh func.txt1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#confuse.sh文件内容#!/bin/bash# 这是Shell脚本，如果不懂shell，自行修炼：http://www.runoob.com/linux/linux-shell.html# 以下使用sqlite3进行增加数据，如果不了解sqlite3命令，自行修炼：http://www.runoob.com/sqlite/sqlite-tutorial.html#数据表名TABLENAME=&quot;ConfuseOC&quot;#数据库名SYMBOL_DB_FILE=&quot;Confuse.db&quot;#要被替换的方法列表文件STRING_SYMBOL_FILE=&quot;$PROJECT_DIR/func.txt&quot;#被替换后的宏定义在此文件里HEAD_FILE=&quot;/Users/jsqb/Desktop/work/大白钱包/JiSuQianBao/confuse.h&quot;#维护数据库方便日后做bug排查createTable()&#123;echo &quot;create table $TABLENAME(src text,des text);&quot; | sqlite3 $SYMBOL_DB_FILE&#125;insertValue()&#123;echo &quot;insert into $TABLENAME values(&apos;$1&apos;,&apos;$2&apos;);&quot; | sqlite3 $SYMBOL_DB_FILE&#125;query()&#123;echo &quot;select * from $TABLENAME where src=&apos;$1&apos;;&quot; | sqlite3 $SYMBOL_DB_FILE&#125;#生成随机16位名称randomString()&#123;openssl rand -base64 64 | tr -cd &apos;a-zA-Z&apos; | head -c 16&#125;#删除旧数据库文件rm -f $SYMBOL_DB_FILE#删除就宏定义文件rm -f $HEAD_FILE#创建数据表createTable#touch命令创建空文件，根据指定的路径touch $HEAD_FILEecho &apos;#ifndef Confuse_h#define Confuse_h&apos; &gt;&gt; $HEAD_FILEecho &quot;//confuse string at `date`&quot; &gt;&gt; $HEAD_FILE#使用cat将方法列表文件里的内容全部读取出来，形成数组，然后逐行读取，并进行替换cat &quot;$STRING_SYMBOL_FILE&quot; | while read -ra line;doif [[ ! -z &quot;$line&quot; ]]thenrandom=`randomString`echo $line $random#将生成的随机字符串插入到表格中insertValue $line $random#将生成的字符串写入到宏定义文件中，变量是$HEAD_FILEecho &quot;#define $line $random&quot; &gt;&gt; $HEAD_FILEfidoneecho &quot;#endif&quot; &gt;&gt; $HEAD_FILEsqlite3 $SYMBOL_DB_FILE .dump 2.在项目中增加脚本执行地址12Build Phases + run scirpt phase把脚本地址拖到里面 ps ：/Users/jsqb/Desktop/work/大白钱包/JiSuQianBao/confuse.sh 3.新建编译文件confuse.h 脚本会自动匹配生成替换字符串 在pch中导入confuse.h4.把需要替换的方法名放入func.txt12345678loadStatusRefreshreportToKDinitViewControllerssetTabbarImageWithNavandNormalImageandSelectedImageshowTabWithHelpconvertDateToLocalTime 5.保存后，编译项目confuse.h就会自动生成宏定义替换字符串(注：一些和系统名称相同的类不要随便替换会报错)12345678#define loadStatusRefresh QsPxuKmDMDjtYcsk#define reportToKD lxLArIhwQyNbEVbN#define initViewControllers rAImRoptGFPzENKx#define setTabbarImageWithNav SduMdxpwpEOxAlVe#define andNormalImage EBrrMBhpKnkRsPGX#define andSelectedImage QAnLlEOYYsSjlOCN#define showTabWithHelp nKmmEEkZPSrSmGhD#define convertDateToLocalTime OumSVUuuMCyNDtxu]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>oc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS代码混淆]]></title>
    <url>%2F2018%2F09%2F22%2F%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86%2F</url>
    <content type="text"><![CDATA[iOS 审核4.3金融类APP马甲包问题 利用shell脚本更改.h中暴露的接口 用宏定义随机字母代替混淆代码 1.在项目跟目录下创建 confuse.sh func.txt1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#confuse.sh文件内容#!/bin/bash# 这是Shell脚本，如果不懂shell，自行修炼：http://www.runoob.com/linux/linux-shell.html# 以下使用sqlite3进行增加数据，如果不了解sqlite3命令，自行修炼：http://www.runoob.com/sqlite/sqlite-tutorial.html#数据表名TABLENAME=&quot;ConfuseOC&quot;#数据库名SYMBOL_DB_FILE=&quot;Confuse.db&quot;#要被替换的方法列表文件STRING_SYMBOL_FILE=&quot;$PROJECT_DIR/func.txt&quot;#被替换后的宏定义在此文件里HEAD_FILE=&quot;/Users/jsqb/Desktop/work/大白钱包/JiSuQianBao/confuse.h&quot;#维护数据库方便日后做bug排查createTable()&#123;echo &quot;create table $TABLENAME(src text,des text);&quot; | sqlite3 $SYMBOL_DB_FILE&#125;insertValue()&#123;echo &quot;insert into $TABLENAME values(&apos;$1&apos;,&apos;$2&apos;);&quot; | sqlite3 $SYMBOL_DB_FILE&#125;query()&#123;echo &quot;select * from $TABLENAME where src=&apos;$1&apos;;&quot; | sqlite3 $SYMBOL_DB_FILE&#125;#生成随机16位名称randomString()&#123;openssl rand -base64 64 | tr -cd &apos;a-zA-Z&apos; | head -c 16&#125;#删除旧数据库文件rm -f $SYMBOL_DB_FILE#删除就宏定义文件rm -f $HEAD_FILE#创建数据表createTable#touch命令创建空文件，根据指定的路径touch $HEAD_FILEecho &apos;#ifndef Confuse_h#define Confuse_h&apos; &gt;&gt; $HEAD_FILEecho &quot;//confuse string at `date`&quot; &gt;&gt; $HEAD_FILE#使用cat将方法列表文件里的内容全部读取出来，形成数组，然后逐行读取，并进行替换cat &quot;$STRING_SYMBOL_FILE&quot; | while read -ra line;doif [[ ! -z &quot;$line&quot; ]]thenrandom=`randomString`echo $line $random#将生成的随机字符串插入到表格中insertValue $line $random#将生成的字符串写入到宏定义文件中，变量是$HEAD_FILEecho &quot;#define $line $random&quot; &gt;&gt; $HEAD_FILEfidoneecho &quot;#endif&quot; &gt;&gt; $HEAD_FILEsqlite3 $SYMBOL_DB_FILE .dump 2.在项目中增加脚本执行地址12Build Phases + run scirpt phase把脚本地址拖到里面 ps ：/Users/jsqb/Desktop/work/大白钱包/JiSuQianBao/confuse.sh 3.新建编译文件confuse.h 脚本会自动匹配生成替换字符串 在pch中导入confuse.h4.把需要替换的方法名放入func.txt12345678loadStatusRefreshreportToKDinitViewControllerssetTabbarImageWithNavandNormalImageandSelectedImageshowTabWithHelpconvertDateToLocalTime 5.保存后，编译项目confuse.h就会自动生成宏定义替换字符串(注：一些和系统名称相同的类不要随便替换会报错)12345678#define loadStatusRefresh QsPxuKmDMDjtYcsk#define reportToKD lxLArIhwQyNbEVbN#define initViewControllers rAImRoptGFPzENKx#define setTabbarImageWithNav SduMdxpwpEOxAlVe#define andNormalImage EBrrMBhpKnkRsPGX#define andSelectedImage QAnLlEOYYsSjlOCN#define showTabWithHelp nKmmEEkZPSrSmGhD#define convertDateToLocalTime OumSVUuuMCyNDtxu]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>oc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS设计模式]]></title>
    <url>%2F2018%2F05%2F11%2F%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[MVVM + RAC1VM: 相比较于MVC新引入的视图模型。是视图显示逻辑、网络请求、跳转动作等代码存放的地方，唯一要注意的是，任何视图本身的引用都不应该放在VM中，换句话说就是VM中不要引入UIKit.h，VM整体可做独立测试 (对于image这个，也有人将其看做数据来处理，这就看个人想法了，并不影响整体的架构)。 MVP1Presenter: 通过数据和状态更新View MVC 对标 MVVM 有何不同？12MVC C随着业务不断更新迭代，逻辑代码量巨大，V和C耦合紧密使用MVVM 可抽离对应业务逻辑，相应网络请求，Action等一些列逻辑处理代码，并且可独立测试。 请讲述下KVC KVO 通知原理KVC1简称KeyValueCoding，是一个基于NSKeyValueCoding非正式协议的机制，就是直接通过key值对对象的属性进行存取操作，而不是通过明确的存取方法，简而言之也就是一系列规则和方法进行的存取操作，系统就会根据key来进行一个搜索，系统会按照数据类型的方式继续找，直到找到返回。 KVO12KVO是基于runtime机制实现的当某个类的属性对象第一次被观察时，系统就会在运行期动态地创建该类的一个派生类，在这个派生类中重写基类中任何被观察属性的setter 方法。派生类在被重写的setter方法内实现真正的通知机制 通知原理1iOS消息通知机制算是同步的，观察者只要向消息中心注册， 即可接受其他对象发送来的消息，消息发送者和消息接受者两者可以互相一无所知，完全解耦。这种消息通知机制可以应用于任意时间和任何对象，观察者可以有多个，所以消息具有广播的性质，只是需要注意的是，观察者向消息中心注册以后，在不需要接受消息时需要向消息中心注销，属于典型的观察者模式。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>oc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于AFN的网络库封装]]></title>
    <url>%2F2018%2F03%2F03%2F%E5%9F%BA%E4%BA%8EAFN%E7%BD%91%E7%BB%9C%E5%BA%93%2F</url>
    <content type="text"><![CDATA[第一层 HMRequest 功能 HTTP 常用请求方式 GET POST PUT PATCH DELETE POST 上传JSON数据 PHOTO 单张多张照片上传 HMRequest.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#import &lt;UIKit/UIKit.h&gt;#import &lt;Foundation/Foundation.h&gt;@interface HMRequestModel : HMBaseModel@property (nonatomic, strong) NSNumber *code;@property (nonatomic, copy) NSString *message;@endtypedef void(^HMRequestSuccessBlock)(id result, HMRequestModel *model);typedef void(^HMRequestFailureBlock)(NSString *msg);typedef NS_ENUM(NSInteger, HMRequestMethod) &#123;HTTP_REQUEST_TYPE_GET = 0,HTTP_REQUEST_TYPE_POST = 1,HTTP_REQUEST_TYPE_PUT = 2,HTTP_REQUEST_TYPE_PATCH = 3,HTTP_REQUEST_TYPE_DELETE = 4,&#125;;typedef NS_ENUM(NSInteger, HMRequestStatus) &#123;HTTP_REQUEST_STATUS_FAILURE = -1,HTTP_REQUEST_STATUS_SUCCESS = 0&#125;;@interface HMRequest : NSObject#pragma mark- http request+ (void)hm_requestActionWithUrl:(NSString *)urlparams:(NSDictionary *)paramsmethod:(HMRequestMethod)methodsuccess:(HMRequestSuccessBlock)successfailure:(HMRequestFailureBlock)failure;#pragma mark- json request+ (void)hm_postJsonDataWithUrl:(NSString *)urlparams:(NSDictionary *)paramssuccess:(HMRequestSuccessBlock)successfailure:(HMRequestFailureBlock)failure;#pragma mark- photo request+ (void)hm_upLoadPhotoWithUrl:(NSString *)urlparams:(NSDictionary *)paramsphotoSize:(CGSize)photoSizephotos:(NSArray *)photossuccess:(HMRequestSuccessBlock)successfailure:(HMRequestFailureBlock)failure;@end HMRequest.m123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166#import &quot;HMRequest.h&quot;@implementation HMRequestModel@end@implementation HMRequest+ (void)hm_requestActionWithUrl:(NSString *)urlparams:(NSDictionary *)paramsmethod:(HMRequestMethod)methodsuccess:(HMRequestSuccessBlock)successfailure:(HMRequestFailureBlock)failure&#123;// [HMServerConfig HMServerAddress] 为正式/测试环境前缀可自行处理NSString *requestUrl = HM_FORMAT_TWO(@&quot;%@%@&quot;, [HMServerConfig HMServerAddress], url);requestUrl = [requestUrl stringByAddingPercentEncodingWithAllowedCharacters:[NSCharacterSet URLQueryAllowedCharacterSet]];if (method == HTTP_REQUEST_TYPE_GET) &#123;[[HMRequest manager] GET:requestUrlparameters:paramsprogress:nilsuccess:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) &#123;HMRequestModel *model = [HMRequestModel yy_modelWithDictionary:responseObject];if ([model.code integerValue] == HTTP_REQUEST_STATUS_SUCCESS) success(responseObject, model);if ([model.code integerValue] == HTTP_REQUEST_STATUS_FAILURE) success(nil, model);&#125;failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;failure([HMRequest errorInfo:error]);&#125;];&#125;if (method == HTTP_REQUEST_TYPE_POST) &#123;[[HMRequest manager] POST:requestUrlparameters:params progress:nilsuccess:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) &#123;HMRequestModel *model = [HMRequestModel yy_modelWithDictionary:responseObject];if ([model.code integerValue] == HTTP_REQUEST_STATUS_SUCCESS) success(responseObject, model);if ([model.code integerValue] == HTTP_REQUEST_STATUS_FAILURE) success(nil, model);&#125;failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;failure([HMRequest errorInfo:error]);&#125;];&#125;if (method == HTTP_REQUEST_TYPE_PUT) &#123;[[HMRequest manager] PUT:requestUrlparameters:paramssuccess:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) &#123;HMRequestModel *model = [HMRequestModel yy_modelWithDictionary:responseObject];if ([model.code integerValue] == HTTP_REQUEST_STATUS_SUCCESS) success(responseObject, model);if ([model.code integerValue] == HTTP_REQUEST_STATUS_FAILURE) success(nil, model);&#125;failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;failure([HMRequest errorInfo:error]);&#125;];&#125;if (method == HTTP_REQUEST_TYPE_PATCH) &#123;[[HMRequest manager] PATCH:requestUrlparameters:paramssuccess:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) &#123;HMRequestModel *model = [HMRequestModel yy_modelWithDictionary:responseObject];if ([model.code integerValue] == HTTP_REQUEST_STATUS_SUCCESS) success(responseObject, model);if ([model.code integerValue] == HTTP_REQUEST_STATUS_FAILURE) success(nil, model);&#125;failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;failure([HMRequest errorInfo:error]);&#125;];&#125;if (method == HTTP_REQUEST_TYPE_DELETE) &#123;[[HMRequest manager] DELETE:requestUrlparameters:paramssuccess:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) &#123;HMRequestModel *model = [HMRequestModel yy_modelWithDictionary:responseObject];if ([model.code integerValue] == HTTP_REQUEST_STATUS_SUCCESS) success(responseObject, model);if ([model.code integerValue] == HTTP_REQUEST_STATUS_FAILURE) success(nil, model);&#125;failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;failure([HMRequest errorInfo:error]);&#125;];&#125;&#125;+ (void)hm_postJsonDataWithUrl:(NSString *)urlparams:(NSDictionary *)paramssuccess:(HMRequestSuccessBlock)successfailure:(HMRequestFailureBlock)failure&#123;NSString *requestUrl = HM_FORMAT_TWO(@&quot;%@%@&quot;, [HMServerConfig HMServerAddress], url);requestUrl = [requestUrl stringByAddingPercentEncodingWithAllowedCharacters:[NSCharacterSet URLQueryAllowedCharacterSet]];NSError *error;NSData *jsonData = [NSJSONSerialization dataWithJSONObject:params options:0 error:&amp;error];NSString *jsonString = [[NSString alloc] initWithData:jsonData encoding:NSUTF8StringEncoding];AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]];NSMutableURLRequest *request = [[AFJSONRequestSerializer serializer] requestWithMethod:@&quot;POST&quot; URLString:requestUrl parameters:nil error:nil];[request setValue:@&quot;application/json&quot; forHTTPHeaderField:@&quot;Content-Type&quot;];[request setValue:@&quot;application/json&quot; forHTTPHeaderField:@&quot;Accept&quot;];[request setHTTPBody:[jsonString dataUsingEncoding:NSUTF8StringEncoding]];[[manager dataTaskWithRequest:request completionHandler:^(NSURLResponse * _Nonnull response, id _Nullable responseObject, NSError * _Nullable error) &#123;if (responseObject) &#123;HMRequestModel *model = [HMRequestModel yy_modelWithDictionary:responseObject];if ([model.code integerValue] == HTTP_REQUEST_STATUS_SUCCESS) success(responseObject, model);if ([model.code integerValue] == HTTP_REQUEST_STATUS_FAILURE) success(nil, model);&#125; else &#123;failure([HMRequest errorInfo:error]);&#125;&#125;] resume];&#125;+ (void)hm_upLoadPhotoWithUrl:(NSString *)urlparams:(NSDictionary *)paramsphotoSize:(CGSize)photoSizephotos:(NSArray *)photossuccess:(HMRequestSuccessBlock)successfailure:(HMRequestFailureBlock)failure&#123;NSString *requestUrl = HM_FORMAT_TWO(@&quot;%@%@&quot;, [HMServerConfig HMServerAddress], url);requestUrl = [requestUrl stringByAddingPercentEncodingWithAllowedCharacters:[NSCharacterSet URLQueryAllowedCharacterSet]];NSLog(@&quot;url:%@\nparams:%@&quot;, requestUrl, params);AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];manager.requestSerializer = [AFHTTPRequestSerializer serializer];manager.responseSerializer = [AFJSONResponseSerializer serializer];[SVProgressHUD show];[manager POST:requestUrl parameters:params constructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt; _Nonnull formData) &#123;for (int i = 0; i &lt; photos.count; i++) &#123;NSData *imageData = UIImageJPEGRepresentation(photos[i], 0.6f);NSLog(@&quot;upload image size: %ld k&quot;, (long)(imageData.length / 1024));NSDateFormatter *formatter = [NSDateFormatter new];formatter.dateFormat = @&quot;yyyyMMddHHmmss&quot;;NSString *imageName = [formatter stringFromDate:[NSDate date]];NSString *fileName = [NSString stringWithFormat:@&quot;%@.jpg&quot;,imageName];[formData appendPartWithFileData:imageData name:@&quot;image&quot; fileName:fileName mimeType:@&quot;image/jpeg&quot;];&#125;&#125; progress:^(NSProgress * _Nonnull uploadProgress) &#123;&#125; success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) &#123;HMRequestModel *model = [HMRequestModel yy_modelWithDictionary:responseObject];if ([model.code integerValue] == HTTP_REQUEST_STATUS_SUCCESS) success(responseObject, model);if ([model.code integerValue] == HTTP_REQUEST_STATUS_FAILURE) success(nil, model);NSLog(@&quot;responseObject:%@&quot;, responseObject);[SVProgressHUD dismiss];&#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;failure([HMRequest errorInfo:error]);&#125;];&#125;+ (NSString *)errorInfo:(NSError *)error&#123;return error.userInfo[@&quot;message&quot;] ? error.userInfo[@&quot;message&quot;] : @&quot;网络断开连接，请稍后再试&quot;;&#125;+ (AFHTTPSessionManager *)manager&#123;AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];[manager.responseSerializer setAcceptableContentTypes:[NSSet setWithObjects:@&quot;text/html&quot;,@&quot;text/css&quot;,@&quot;text/json&quot;,@&quot;text/javascript&quot;,@&quot;text/plain&quot;,@&quot;application/json&quot;,@&quot;application/x-javascript&quot;,@&quot;application/javascript&quot;,@&quot;application/vnd.api+json&quot;, nil]];return manager;&#125;@end 第二层 HMService 功能- 按模块进行category类别划分（例如HMNetService、HMNetService+mine）HMService.h12345678910#import &quot;HMNetService.h&quot;@interface HMNetService (mine)// 个人信息 -&gt; 上传照片+ (void)upLoadWithPhotos:(NSArray *)photostype:(NSNumber *)typecomplete:(MultiActionBlock)complete;@end HMService.m12345678910111213141516171819202122#import &quot;HMNetService+mine.h&quot;static NSString * const upLoadImageUrl = @&quot;/upload/image&quot;;@implementation HMNetService (mine)+ (void)upLoadWithPhotos:(NSArray *)photostype:(NSNumber *)typecomplete:(MultiActionBlock)complete&#123;HMParams *params = [HMParams new];[params addParam:@&quot;type&quot; value:type];[HMRequest hm_upLoadPhotoWithUrl:upLoadImageUrlparams:params.paramsphotoSize:CGSizeMake(50, 50)photos:photossuccess:^(id result, HMRequestModel *model) &#123;complete(result, model, model.message);&#125; failure:^(NSString *msg) &#123;complete(nil, nil, msg);&#125;];&#125; 第三层 外部调用实现功能- block回调，非常简洁只关注最后结果做处理12345678910[HMNetService upLoadWithPhotos:@[photo]type:@(type)complete:^(NSDictionary *result, HMRequestModel *requestModel, NSString *message) &#123;if (result) &#123;// 成功处理&#125; else &#123;// 失败处理&#125;[[iToast makeText:message] show];&#125;];]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>oc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自动化神器 fastlane]]></title>
    <url>%2F2018%2F01%2F12%2Ffastlane%2F</url>
    <content type="text"><![CDATA[Fastlane 是用Ruby语言编写的一套自动化工具集和框架，每一个工具实际都对应一个Ruby脚本，用来执行某一个特定的任务，而Fastlane核心框架则允许使用者通过类似配置文件的形式，将不同的工具有机而灵活的结合在一起，从而形成一个个完整的自动化流程。 先进行fastlane的安装1sudo gem install fastlane --verbose 确保Xcode安装了最新版本命令行工具1xcode-select --install 如果fastlane加载缓慢,请尝试运行1gem clean up 找到项根目目录1cd /Users/jsqb/Desktop/iOS 执行fastlane安装12执行 fastlane init配置开发者账户user，password，bundle identfier 会生成fastlane文件12Appfile - 包含你的app_id bundle id 如果上步init的时候你输入了正确的appId账号和密码会在这里生成正确的team_id信息Fastfile - 是最重要的一个文件，编写和定制我们打包脚本的一个文件 fastlane 工具 除fastlane命令,你还可以访问以下fastlane工具 deliver: 上传截图, 元数据, app应用程序到App Store supply: 上传Android app应用程序和元数据到Google Play snapshot: 自动捕获iOS app应用程序本地截图 screengrab: 自动捕获Android app应用程序本地截图 frameit: 快速截屏并将截屏放入设备中 pem: 自动生成和更新推送通知配置文件 sigh: 开发证书和描述文件下载 produce: 使用命令行在iTunes Connect上创建新的app和开发入口 cert: 自动创建和配置iOS代码签名证书 spaceship: Ruby 库访问 Apple开发者中心和 iTunes Connect pilot: 最好的方式管理你的TestFlight 测试人员和从终端构建 boarding: 最简单的方式邀请你的TestFlight beta测试人员 gym: iOS app打包签名自动化工具 match: 使用Git同步你的团队证书和配置文件 scan: 最简单方式测试你的 iOS 和 Mac apps 我们使用gym来做自动化打包在生成的fastlane文件中新增 .env文件,配置文件内容如下可自行扩展 12345678910111213141516171819202122232425262728293031323334353637383940414243# .env全局配置文件# bundleIdAPP_IDENTIFIER = &quot;com.xqb.R&quot;# 蒲公英,更新描述PGY_UPDATE_DESCRIPTION = &quot;3.0.0测试包&quot;# 自动提交审核SUBMIT_FOR_REVIEW = false# 审核通过后立刻发布AUTOMATIC_RELEASE = false# 苹果开发者账号APPLE_ID = &quot;xxxxx@qq.com&quot;# 苹果开发者帐号密码FASTLANE_PASSWORD = &quot;xxxxx&quot;# 套装IDTEAM_ID = &quot;xxxx&quot;# APP元数据及截图存放路径METADATA_PATH = &quot;./metadata/TestGitProject&quot;SCREENSHOTS_PATH = &quot;./screenshots/TestGitProject&quot;# APP元数据及截图下载时，直接覆盖原有数据，不询问DELIVER_FORCE_OVERWRITE = true# 包名SCHEME = &quot;KDFDApp&quot;# 指定打包方式，Release 或者 DebugCONFIGURATION = &quot;Debug&quot;# 指定打包所使用的输出方式，目前支持app-store, package, ad-hoc, enterprise, developmentEXPORT_METHOD = &quot;enterprise&quot;# 蒲公英api key 蒲公英平台提供PGY_API_KEY = &quot;xxxx&quot;# 蒲公英api keyPGY_USER_KEY = &quot;xxxx&quot; Appfile 文件内容123app_identifier ENV[&apos;APP_IDENTIFIER&apos;]apple_id ENV[&apos;APPLE_ID&apos;]team_id ENV[&apos;TEAM_ID&apos;] Deliverfile 文件内容12app_identifier ENV[&apos;APP_IDENTIFIER&apos;]username ENV[&apos;APPLE_ID&apos;] 安装蒲公英的 Fastlane 插件1终端输入 astlane add_plugin pgyer 在生成的Gemfile文件中新增1gem &apos;cocoapods&apos; 最后我们编写fastlile文件来运行运行脚本1234567891011121314151617181920212223242526desc &quot;发布测试版本到蒲公英&quot;lane :qb_pgy dogym(scheme: ENV[&apos;SCHEME&apos;],silent: true, # 隐藏没有必要的信息include_symbols: true, # 是否生成符号表，默认trueinclude_bitcode: true, # 是否开启bitcode,默认trueclean:true, # 是否清空以前的编译信息 true：是configuration: ENV[&apos;CONFIGURATION&apos;],export_method: ENV[&apos;EXPORT_METHOD&apos;],output_name: &quot;极速钱包&quot;, # 输出文件名output_directory: &quot;./fastlane/bulid&quot;) # 指定输出文件夹pgyer(api_key: ENV[&apos;PGY_API_KEY&apos;],user_key: ENV[&apos;PGY_USER_KEY&apos;],update_description: ENV[&apos;PGY_UPDATE_DESCRIPTION&apos;])enddesc &quot;打包正式版本&quot;lane :qb_appStore dogym(scheme: ENV[&apos;SCHEME&apos;],output_name: &quot;极速钱包&quot;, # 输出的ipa名称silent: true, # 隐藏没有必要的信息clean: true, # 在构建前先cleanconfiguration: &quot;Release&quot;, # 配置为Release版本codesigning_identity: &quot;iPhone Distribution: Shanghai Peijun Information Technology Co., Ltd. (DFB9QG8MBN)&quot;, # 代码签名证书buildlog_path: &quot;./fastlane/onLine/fastlanelog&quot;, # fastlane构建ipa的日志输出目录output_directory: &quot;./fastlane/onLine&quot;)end 编写好后先把证书在工程中选择正确，我们就可以在终端中通过fastlane+蒲公英就可以来实现自动化打包发布功能1fastlane qb_pgy 这部分自动化文件没必要提交到远端服务器，我们在gitignore文件中新增忽略信息1*fastlane/ 通过fastfile 就可以定制各种自动化流程]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>oc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础架构 MVC & MVVM]]></title>
    <url>%2F2017%2F12%2F06%2FiOS%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[目录分级建议 Class层级下按TabBar模块进行分类(例如Base基类、工具类Tools、开源库等等) 每个TabBar模块下属子模块进行分类(例如HMModuleOne、HMModuleTwo等等)，子模块按照MVC，MVVM来做处理。 MVC Model 建议 命名xxxModel 例如(speed wallet) SWTextModel 可使用YYModel、或基类BaseModel做容错方法。字典数组之间转换 可在字段后增加注释12@property (copy, nonatomic) NSString *name; //姓名@property (copy, nonatomic) NSString *content; //内容 Controller 建议 UIView的创建和组织 网络请求&amp;数据处理 属性命名应见名之意、驼峰法命名 TableView&amp;Collection代理相关 数据配置cell&amp;view 行数过大可考虑拆分category 可在.h中增加方法名 12345#pragma mark- GET+ (void)getActionWithUrl:(NSString *)urlparams:(NSDictionary *)paramssuccess:(void(^)(id result))resultfiled:(void(^)(NSString *detail, NSError *error))errors; 可在.m中增加方法详细 1234567891011121314151617/**&lt;#Description#&gt;@param url &lt;#url description#&gt;@param size &lt;#size description#&gt;@param images &lt;#images description#&gt;@param result &lt;#result description#&gt;@param errors &lt;#errors description#&gt;*/快捷键 command + option + / 生成注释#pragma mark- GET+ (void)getActionWithUrl:(NSString *)urlparams:(NSDictionary *)paramssuccess:(void(^)(id result))resultfiled:(void(^)(NSString *detail, NSError *error))errors; View 建议 布局、事件绑定 使用model进行配置UI ViewModel 建议 VC业务逻辑拆分处理 数据请求 内存问题建议 block 循环引用问题 NSNotificationCenter &amp; RemoveObserver 匹配 Git相关使用建议 master 正式环境分支 dev 测试环境分支 dev-zhaoying 团队个人分支 dev-hongyu 团队个人分支 后续可建议，团队个人只可push个人分支，由团队负责人codeReView后进行合并等处理]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>oc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS属性修饰关键字都有哪些?]]></title>
    <url>%2F2017%2F09%2F03%2FiOS%E5%B1%9E%E6%80%A7%E4%BF%AE%E9%A5%B0%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%2F</url>
    <content type="text"><![CDATA[atomic 原子性访问，对属性赋值的时候加锁 noatomic 非原子性访问，对属性赋值的时候不加锁，多线程并发访问会提高性能 strong OC对象-强引用，表示实例变量对传入的对象要有所有权关系 assige 非OC对象(number,bool)，简单赋值，引用计数不会增加 retain release旧对象，将旧对象的值赋予输入对象，属于浅拷贝-指针复制 copy setter方法进行copy操作,和retain处理流程一样，先旧值release，开辟内存copy对象，属于深拷贝-内容复制 weak 引用对象的引用计数不会增加，并在对象被释放的时候自动被设置为nil readwrite 可读可写，表示该属性同时拥有setter和getter readonly 只读属性，表示只有getter没有setter，不希望属性在类外部改变 nullable 声明的属性可以为空 nonnull 声明的属性不能为空 非集合类对象copy和mutableCopy12345[不可变对象 copy] //浅复制[不可变对象 mutableCopy] //深复制[可变对象 copy] //深复制[可变对象 mutableCopy] //深复制copy是不可以被修改的 mutableCopy是可以修改的 用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？ 因为父类指针可以指向子类对象,使用copy的目的是为了让本对象的属性不受外界影响,使用copy无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本 如果我们使用是strong,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性 代理为什么用weak修饰？ 确保代理执行后，在程序运行的时候不会造成循环引用,对象都会被顺利的销毁,所以会调用代理类的delloc方法 使用strong修饰，在程序运行的时候会造成循环引用，对象都不会的销毁，从而造成了内存泄露的问题 block为什么要用copy修饰？ block的内存地址开辟在栈区，栈区的特点就是创建的对象随时会被销毁掉，一但这个销毁了，再去调用这个对象，就会造成crash，用copy修饰后内存在堆区，不会函数调用完就结束，随对象销毁才销毁 assign与weak区别assign 适用于基本数据类型，weak 适用于 NSObject 对象 12345Q: assign 其实可以修饰对象，那为什么不用来修饰对象呢？被 assign 修饰的对象在释放后，指针的地址还是存在的，也就是说指针并没有被置为 nil，造成野指针。Q: 为什么可以用 assign 修饰基本数据类型？基本数据类型一般分配在栈上，栈中的内存是有系统自动管理的，不会造成野指针weak 修饰的对象在释放后，指针地址会被置为 nil。 weak实现原理？runtime 维护了一个weak表，本质是哈希表(hash)，key是所指对象的地址，value是weak指针的地址组成的数组 1.初始化创建时，runtime会调用objc_initWeak函数，创建一个new weak指针指向对象地址2.添加引用时，objc_initWeak会调用objc_storeWeak，更新指针指向，创建对应的weak弱引用表3.释放时，会调用clearDeallocating函数，通过对象地址也是key的值，找到对应的value数组，进行遍历，将其中的要处理的数据设为nil，把这个entry从weak表中删除，清理对象]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>oc</tag>
      </tags>
  </entry>
</search>
